// Copyright 2022 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package cmd

import (
	"fmt"
	"strings"

	"github.com/dave/jennifer/jen"
	"github.com/hashicorp/terraform-config-inspect/tfconfig"
	"github.com/iancoleman/strcase"
)

const (
	tfgenImportPkgPath = "github.com/bharathkkb/tfpkg/pkg/tfgen"
	tfgenPkg           = "tfgen"
)

// generatePkgFromMod generates go source code from a given module.
// todo(bharathkkb): refactor and testing
func generatePkgFromMod(pkgName, src, version string, m *tfconfig.Module) string {
	f := jen.NewFile(pkgName)
	f.PackageComment("This file is generated by github.com/bharathkkb/tfpkg. Do not edit.")
	// generate import statement
	f.ImportName(tfgenImportPkgPath, tfgenPkg)
	// generate fields for required and optional attribs
	reqAttribs := []jen.Code{}
	optionalAttribs := []jen.Code{}
	reqAttribsVars := make(map[string]string)
	optionalAttribsVars := make(map[string]string)
	for varName, varData := range m.Variables {
		varStructName := strcase.ToCamel(varName)
		attrib := jen.Id(varStructName)
		getGoTypeFromTFType(varData.Type, attrib)
		if varData.Required {
			reqAttribs = append(reqAttribs, attrib)
			reqAttribsVars[varName] = varStructName
		} else {
			optionalAttribs = append(optionalAttribs, attrib)
			optionalAttribsVars[varName] = varStructName
		}
	}
	// add fields to required and optional structs
	f.Comment("Inputs marked as required by the module")
	f.Type().Id("RequiredAttrib").Struct(reqAttribs...)
	f.Empty()
	f.Comment("Inputs with a default value in the module")
	f.Type().Id("OptionalAttrib").Struct(optionalAttribs...)

	// generate fields for Mod struct
	name := jen.Id("name").Qual("", "string")
	required := jen.Id("Required").Qual("", "*RequiredAttrib")
	optional := jen.Id("Optional").Qual("", "*OptionalAttrib")

	// generate Mod struct
	f.Type().Id("Mod").Struct(
		jen.Qual(tfgenImportPkgPath, "Module"),
		required,
		optional,
	)
	f.Empty()

	// Options for initialization in constructor
	modOptions := []jen.Code{jen.Id("name"), jen.Qual(tfgenImportPkgPath, "ModuleWithSource").Call(jen.Lit(src))}
	if version != "" {
		modOptions = append(modOptions, jen.Qual(tfgenImportPkgPath, "ModuleWithVersion").Call(jen.Lit(version)))
	}
	modDef := jen.Id("mod").Op(":=").Qual(tfgenImportPkgPath, "NewModule").Call(modOptions...)
	mod := jen.Id("n").Op(":=").Id("Mod").Values(jen.Dict{
		jen.Id("Module"):   jen.Op("*").Id("mod"),
		jen.Id("Required"): jen.Id("required"),
		jen.Id("Optional"): jen.Id("optional"),
	})
	assignFunc := []jen.Code{modDef, mod}

	// constructor body assigning required/optional attribs to underlying module
	for k, v := range reqAttribsVars {
		assigner := jen.Id("n.AddAttribute").Call(jen.Lit(k), jen.Id("required").Dot(v))
		assignFunc = append(assignFunc, assigner)
	}

	for k, v := range optionalAttribsVars {
		assigner := jen.Id("n.AddAttribute").Call(jen.Lit(k), jen.Id("optional").Dot(v))
		assignFunc = append(assignFunc, assigner)
	}
	assignFunc = append(assignFunc, jen.Return(jen.Id("n")))

	// create constructor and func signature
	ctorFuncSig := []jen.Code{name, jen.Id("required").Qual("", "*RequiredAttrib"), jen.Id("optional").Qual("", "*OptionalAttrib")}
	f.Func().Id("New").Params(ctorFuncSig...).Id("Mod").Block(assignFunc...)

	// add methods for generating references to outputs
	if len(m.Outputs) > 0 {
		f.Comment("Getters for output references from the module")
	}
	for opName := range m.Outputs {
		refFuncName := fmt.Sprintf("Get%sRef", strcase.ToCamel(opName))
		funcContent := jen.Return(jen.Id("m.Ref").Call(jen.Lit(opName)))
		f.Func().Params(jen.Id("m").Id("Mod")).Id(refFuncName).Call().String().Block(funcContent)
		f.Empty()
	}

	// add methods for allowing references as inputs
	if len(m.Variables) > 0 {
		f.Comment("Setters for setting references as inputs")
	}
	for varName := range m.Variables {
		refFuncName := fmt.Sprintf("Set%sAsRef", strcase.ToCamel(varName))
		funcContent := jen.Id("m.AddAttribute").Call(jen.Lit(varName), jen.Id("ref"))
		f.Func().Params(jen.Id("m").Id("*Mod")).Id(refFuncName).Params(jen.Id("ref").String()).Call().Block(funcContent)
		f.Empty()
	}
	return f.GoString()
}

// map tf primitives to go types
var primitiveMap = map[string]func(j *jen.Statement) *jen.Statement{
	"string": func(j *jen.Statement) *jen.Statement { return j.String() },
	"number": func(j *jen.Statement) *jen.Statement { return j.Int() },
	"bool":   func(j *jen.Statement) *jen.Statement { return j.Bool() },
}
var collection = []string{"list", "map", "set"}

func getCollection(t string) (bool, string) {
	for _, ct := range collection {
		if strings.HasPrefix(t, ct) {
			return true, ct
		}
	}
	return false, ""
}

// getGoTypeFromTFType converts a Terraform type t into an equvialent go type recursively.
func getGoTypeFromTFType(t string, j *jen.Statement) *jen.Statement {
	// check if primitive type
	p, isPrimitive := primitiveMap[t]
	if isPrimitive {
		return p(j)
	}
	//check if collection type
	isCollection, ct := getCollection(t)
	if isCollection {
		innerType := getInnerType(t, ct)
		switch ct {
		case "list", "set":
			return getGoTypeFromTFType(innerType, j.Index())
		case "map":
			return getGoTypeFromTFType(innerType, j.Map(jen.String()))

		}
	}
	// unknown type or object, default to string
	return j.String()
}

// getInnerType returns next type in a nested type.
func getInnerType(t string, outer string) string {
	tParen := fmt.Sprintf("%s(", outer)
	return strings.TrimPrefix(strings.TrimPrefix(t, tParen), ")")
}
